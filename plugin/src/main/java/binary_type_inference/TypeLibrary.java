package binary_type_inference;

import ctypes.Ctypes;
import ctypes.Ctypes.Alias;
import ctypes.Ctypes.CType;
import ctypes.Ctypes.CTypeMapping;
import ctypes.Ctypes.Field;
import ctypes.Ctypes.Function;
import ctypes.Ctypes.Parameter;
import ctypes.Ctypes.Pointer;
import ctypes.Ctypes.Primitive;
import ctypes.Ctypes.Structure;
import ctypes.Ctypes.Tid;
import ctypes.Ctypes.TidToNodeIndex;
import generic.stl.Pair;
import ghidra.program.model.data.Composite;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.FunctionDefinitionDataType;
import ghidra.program.model.data.IntegerDataType;
import ghidra.program.model.data.ParameterDefinition;
import ghidra.program.model.data.ParameterDefinitionImpl;
import ghidra.program.model.data.PointerDataType;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.data.UnionDataType;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import org.apache.commons.lang.NotImplementedException;

public class TypeLibrary {
  private final CTypeMapping mapping;
  private final IUnknownTypeBuilder unknownType;
  private final Map<String, DataType> type_constants;

  private final Map<Integer, DataType> node_index_to_type_memoization;
  private final DataTypeManager dtm;

  public static class Types {
    private final Map<Tid, DataType> mapping;

    public Types(Map<Tid, DataType> mapping) {
      this.mapping = mapping;
    }

    public Optional<DataType> getDataTypeForTid(Tid ti) {
      return Optional.ofNullable(mapping.get(ti));
    }
  }

  private static class CTypeBuilder {
    private final int targetIndex;
    // may have multiple structs for a node, keeps the names fresh
    private int type_ctr;
    // Lets us query for node indices
    private final TypeLibrary ty_lib;

    private final CType target_dty;
    private Optional<Composite> root_stub;

    public CTypeBuilder(int targetIndex, CType target_dty, TypeLibrary ty_lib) {
      this.type_ctr = 0;
      this.targetIndex = targetIndex;
      this.ty_lib = ty_lib;
      this.target_dty = target_dty;
      this.root_stub = Optional.empty();
    }

    private int freshID() {
      return this.type_ctr++;
    }

    private ParameterDefinition BuildParamDefForParam(int param_idx, CType param_type) {
      var param_ty = this.buildCtype(param_type, false);
      var param =
          new ParameterDefinitionImpl(
              "func_"
                  + Integer.toString(this.freshID())
                  + "_"
                  + Integer.toString(this.targetIndex)
                  + "param_"
                  + Integer.toString(param_idx),
              param_ty,
              "autogenerated");
      return param;
    }

    private ParameterDefinition BuildDefaultParameter(int param_idx) {
      var param =
          new ParameterDefinitionImpl(
              "func_"
                  + Integer.toString(this.freshID())
                  + "_"
                  + Integer.toString(this.targetIndex)
                  + "param_"
                  + Integer.toString(param_idx),
              this.ty_lib.unknownType.getDefaultUnkownType(),
              "autogenerated");
      return param;
    }

    private DataType buildFunction(Function func) {
      FunctionDefinitionDataType res_type =
          new FunctionDefinitionDataType("func_type_for_" + Integer.toString(this.targetIndex));

      if (func.getHasReturn()) {
        var ret_ty = this.buildCtype(func.getReturnType(), false);
        res_type.setReturnType(ret_ty);
      }

      var max_ind =
          func.getParametersList().stream()
              .map((Parameter p) -> p.getParameterIndex())
              .max(Integer::compare);

      if (!max_ind.isPresent()) {
        // no params.
        return res_type;
      }

      var param_map =
          func.getParametersList().stream()
              .collect(Collectors.toMap(Parameter::getParameterIndex, Parameter::getType));

      var params =
          IntStream.range(0, max_ind.get() + 1)
              .mapToObj(
                  (int param_idx) -> {
                    if (param_map.containsKey(param_idx)) {
                      return this.BuildParamDefForParam(param_idx, param_map.get(param_idx));
                    } else {
                      return this.BuildDefaultParameter(param_idx);
                    }
                  })
              .toArray(ParameterDefinition[]::new);

      res_type.setArguments(params);

      return res_type;
    }

    private DataType buildCtype(CType target, boolean isRoot) {
      var type_case = target.getInnerTypeCase();
      switch (type_case) {
        case ALIAS:
          return this.buildAlias(target.getAlias());
        case STRUCTURE:
          return this.buildStructure(target.getStructure(), isRoot);
        case UNION:
          return this.buildUnion(target.getUnion(), isRoot);
        case POINTER:
          return this.buildPointer(target.getPointer());
        case PRIMITIVE:
          return this.build_primitive(target.getPrimitive());
        case FUNCTION:
          return this.buildFunction(target.getFunction());
        case INNERTYPE_NOT_SET:
        default:
          throw new NotImplementedException("Type case of: " + type_case.toString());
      }
    }

    DataType buildTarget() {
      return this.buildCtype(this.target_dty, true);
    }

    // TODO(ian): this assumes we never get an alias to ourselves
    private DataType buildAlias(Alias to) {
      if (!this.root_stub.isPresent()) {
        return this.ty_lib.build_node_type(to.getToType());
      } else {
        return this.ty_lib.rec_build_node_type(
            to.getToType(), this.targetIndex, this.root_stub.get());
      }
    }

    private static class InsertedField {
      public int bit_size;
      public int byte_offset;

      public InsertedField(int bit_size, int byte_offset) {
        this.bit_size = bit_size;
        this.byte_offset = byte_offset;
      }

      public int get_byte_past_end() {
        return this.byte_offset + (this.bit_size / 8);
      }
    }

    private DataType buildUnion(Ctypes.Union union, boolean isRoot) {

      var st =
          new UnionDataType(
              "union_for_node_"
                  + Integer.toString(this.freshID())
                  + "_"
                  + Integer.toString(this.targetIndex));
      if (isRoot) {
        this.root_stub = Optional.of(st);
      }

      var unsorted_flds = union.getTargetTypesList();

      for (var fld : unsorted_flds) {
        var child_ty = this.buildCtype(fld, false);
        st.add(child_ty);
      }

      return st;
    }

    private DataType buildStructure(Structure struct, boolean isRoot) {

      var st =
          new StructureDataType(
              "struct_for_node_"
                  + Integer.toString(this.freshID())
                  + "_"
                  + Integer.toString(this.targetIndex),
              0);
      if (isRoot) {
        this.root_stub = Optional.of(st);
      }

      var new_fld_list = new ArrayList<Pair<InsertedField, DataType>>();

      var unsorted_flds = struct.getFieldsList();

      var flds =
          unsorted_flds.stream()
              .sorted(
                  (Field f1, Field f2) -> Integer.compare(f1.getByteOffset(), f2.getByteOffset()))
              .collect(Collectors.toList());

      for (var fld : flds) {
        var min_unoccupied = 0;
        if (!new_fld_list.isEmpty()) {
          var last_elem = new_fld_list.get(new_fld_list.size() - 1);
          min_unoccupied = last_elem.first.get_byte_past_end();
        }

        if (fld.getByteOffset() != min_unoccupied) {
          assert (fld.getByteOffset() > min_unoccupied);
          var diff = fld.getByteOffset() - min_unoccupied;
          var diff_in_bits = diff * 8;
          var ifld = new InsertedField(diff_in_bits, min_unoccupied);
          new_fld_list.add(
              new Pair<>(ifld, this.ty_lib.unknownType.getUnknownDataTypeWithSize(diff)));
        }

        var fld_ty = this.buildCtype(fld.getType(), false);

        var refined_ty =
            this.ty_lib.unknownType.refineDataTypeWithSize(fld_ty, fld.getBitSize() / 8);

        new_fld_list.add(
            new Pair<>(new InsertedField(fld.getBitSize(), fld.getByteOffset()), refined_ty));
      }

      for (var to_add : new_fld_list) {
        st.add(
            to_add.second,
            to_add.first.bit_size / 8,
            "field_at_" + Integer.toString(to_add.first.byte_offset),
            "autogen");
      }

      return st;
    }

    private DataType build_primitive(Primitive prim) {
      System.out.println("Prim: " + prim.getTypeConstant());
      // TODO(ian): figure out size based on use
      if (prim.getTypeConstant().equals(OutputBuilder.SPECIAL_WEAK_INTEGER)) {
        return IntegerDataType.dataType;
      }

      return this.ty_lib.type_constants.getOrDefault(
          prim.getTypeConstant(), this.ty_lib.unknownType.getDefaultUnkownType());
    }

    private DataType buildPointer(Pointer ptr) {
      var pointed_to = this.buildCtype(ptr.getToType(), false);
      return new PointerDataType(pointed_to);
    }
  }

  private TypeLibrary(
      CTypeMapping mapping,
      Map<String, DataType> type_constants,
      IUnknownTypeBuilder unknownType,
      DataTypeManager dtm) {
    this.mapping = mapping;
    this.type_constants = type_constants;
    this.unknownType = unknownType;
    this.node_index_to_type_memoization = new HashMap<>();
    this.dtm = dtm;
  }

  private DataType build_ctype(int node_index) {
    var target_node = this.mapping.getNodeTypesMap().get(node_index);
    Objects.requireNonNull(target_node);

    CTypeBuilder bldr = new CTypeBuilder(node_index, target_node, this);
    return bldr.buildTarget();
  }

  // A recursive call to build node type. A builder should never call
  // build_node_type, or else risk an infinite loop
  private DataType rec_build_node_type(int node_index, int prev_index, DataType prev) {
    this.node_index_to_type_memoization.put(prev_index, prev);
    return this.build_node_type(node_index);
  }

  private DataType build_node_type(int node_index) {
    System.out.println("Building node:" + node_index);
    if (this.node_index_to_type_memoization.containsKey(node_index)) {
      return this.node_index_to_type_memoization.get(node_index);
    }

    var res = this.build_ctype(node_index);
    this.node_index_to_type_memoization.put(node_index, res);
    return res;
  }

  private Optional<Pair<Tid, DataType>> get_type_of_tid(TidToNodeIndex type_var) {
    if (this.mapping.containsNodeTypes(type_var.getNodeIndex())) {
      return Optional.of(
          new Pair<Tid, DataType>(
              type_var.getTid(), this.build_node_type(type_var.getNodeIndex())));
    } else {
      return Optional.empty();
    }
  }

  public Types buildMapping() {
    // memoization map

    Map<Tid, DataType> tid_mapping_memo =
        this.mapping.getTypeVariableReprNodesList().stream()
            .map((TidToNodeIndex type_var) -> this.get_type_of_tid(type_var))
            .filter((Optional<Pair<Tid, DataType>> pr) -> pr.isPresent())
            .map(Optional::get)
            .collect(Collectors.toMap((var pr) -> pr.first, (var pr) -> pr.second));

    return new Types(tid_mapping_memo);
  }

  public static TypeLibrary parseFromInputStream(
      InputStream target,
      Map<String, DataType> type_constants,
      IUnknownTypeBuilder unknownType,
      DataTypeManager dtm)
      throws IOException {
    var mapping = CTypeMapping.parseFrom(target);
    return new TypeLibrary(mapping, type_constants, unknownType, dtm);
  }
}
