package binary_type_inference;

import ctypes.Ctypes;
import ctypes.Ctypes.Alias;
import ctypes.Ctypes.CType;
import ctypes.Ctypes.CType.InnerTypeCase;
import ctypes.Ctypes.CTypeMapping;
import ctypes.Ctypes.Field;
import ctypes.Ctypes.Function;
import ctypes.Ctypes.Parameter;
import ctypes.Ctypes.Pointer;
import ctypes.Ctypes.Primitive;
import ctypes.Ctypes.Structure;
import ctypes.Ctypes.Tid;
import ctypes.Ctypes.TidToTypeId;
import generic.stl.Pair;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeManager;
import ghidra.program.model.data.FunctionDefinitionDataType;
import ghidra.program.model.data.IntegerDataType;
import ghidra.program.model.data.ParameterDefinition;
import ghidra.program.model.data.ParameterDefinitionImpl;
import ghidra.program.model.data.PointerDataType;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.data.UnionDataType;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import org.apache.commons.lang3.NotImplementedException;

public class TypeLibrary {
  private final CTypeMapping mapping;
  private final IUnknownTypeBuilder unknownType;
  private final Map<String, DataType> type_constants;

  private final Map<Integer, DataType> node_index_to_type_memoization;

  // We keep track of visited node indeces that we could not memoize since they
  // were not composites, if we reach a loop thorugh a non memoized type we need
  // to fail otherwise we will diverge.
  private final Set<Integer> visited_node_indeces;

  public static class Types {
    private final Map<Tid, DataType> mapping;

    public Types(Map<Tid, DataType> mapping) {
      this.mapping = mapping;
    }

    public Optional<DataType> getDataTypeForTid(Tid ti) {
      return Optional.ofNullable(mapping.get(ti));
    }
  }

  private static class CTypeBuilder {
    private final int targetIndex;
    // may have multiple structs for a node, keeps the names fresh
    private int type_ctr;
    // Lets us query for node indices
    private final TypeLibrary ty_lib;

    private final CType target_dty;

    public CTypeBuilder(int targetIndex, CType target_dty, TypeLibrary ty_lib) {
      this.type_ctr = 0;
      this.targetIndex = targetIndex;
      this.ty_lib = ty_lib;
      this.target_dty = target_dty;
    }

    private int freshID() {
      return this.type_ctr++;
    }

    private ParameterDefinition BuildParamDefForParam(int param_idx, int param_type) {
      var param_ty = this.ty_lib.rec_build_node_type_without_root(param_type, this.targetIndex);
      var param =
          new ParameterDefinitionImpl(
              "func_"
                  + Integer.toString(this.freshID())
                  + "_"
                  + Integer.toString(this.targetIndex)
                  + "param_"
                  + Integer.toString(param_idx),
              param_ty,
              "autogenerated");
      return param;
    }

    private ParameterDefinition BuildDefaultParameter(int param_idx) {
      var param =
          new ParameterDefinitionImpl(
              "func_"
                  + Integer.toString(this.freshID())
                  + "_"
                  + Integer.toString(this.targetIndex)
                  + "param_"
                  + Integer.toString(param_idx),
              this.ty_lib.unknownType.getDefaultUnkownType(),
              "autogenerated");
      return param;
    }

    private DataType buildFunction(Function func) {
      FunctionDefinitionDataType res_type =
          new FunctionDefinitionDataType("func_type_for_" + Integer.toString(this.targetIndex));

      if (func.getHasReturn()) {
        var ret_ty =
            this.ty_lib.rec_build_node_type_without_root(
                func.getReturnType().getTypeId(), this.targetIndex);
        res_type.setReturnType(ret_ty);
      }

      var max_ind =
          func.getParametersList().stream()
              .map((Parameter p) -> p.getParameterIndex())
              .max(Integer::compare);

      if (!max_ind.isPresent()) {
        // no params.
        return res_type;
      }

      var param_map =
          func.getParametersList().stream()
              .collect(Collectors.toMap(Parameter::getParameterIndex, Parameter::getTypeIndex));

      var params =
          IntStream.range(0, max_ind.get() + 1)
              .mapToObj(
                  (int param_idx) -> {
                    if (param_map.containsKey(param_idx)) {
                      return this.BuildParamDefForParam(
                          param_idx, param_map.get(param_idx).getTypeId());
                    } else {
                      return this.BuildDefaultParameter(param_idx);
                    }
                  })
              .toArray(ParameterDefinition[]::new);

      res_type.setArguments(params);

      return res_type;
    }

    private DataType buildCtype(CType target) {
      var type_case = target.getInnerTypeCase();
      switch (type_case) {
        case ALIAS:
          return this.buildAlias(target.getAlias());
        case POINTER:
          return this.buildPointer(target.getPointer());
        case PRIMITIVE:
          return this.build_primitive(target.getPrimitive());
        case FUNCTION:
          return this.buildFunction(target.getFunction());
        case INNERTYPE_NOT_SET:
        default:
          throw new NotImplementedException("Type case of: " + type_case.toString());
      }
    }

    DataType buildTarget() {
      return this.buildCtype(this.target_dty);
    }

    // TODO(ian): this assumes we never get an alias to ourselves
    private DataType buildAlias(Alias to) {
      return this.ty_lib.rec_build_node_type_without_root(
          to.getToType().getTypeId(), this.targetIndex);
    }

    private DataType build_primitive(Primitive prim) {
      // TODO(ian): figure out size based on use
      if (prim.getTypeConstant().equals(OutputBuilder.SPECIAL_WEAK_INTEGER)) {
        return IntegerDataType.dataType;
      }

      return this.ty_lib.type_constants.getOrDefault(
          prim.getTypeConstant(), this.ty_lib.unknownType.getDefaultUnkownType());
    }

    private DataType buildPointer(Pointer ptr) {
      var pointed_to =
          this.ty_lib.rec_build_node_type_without_root(
              ptr.getToTypeId().getTypeId(), this.targetIndex);
      return new PointerDataType(pointed_to);
    }
  }

  private TypeLibrary(
      CTypeMapping mapping,
      Map<String, DataType> type_constants,
      IUnknownTypeBuilder unknownType,
      DataTypeManager dtm) {
    this.mapping = mapping;

    this.type_constants = type_constants;
    this.unknownType = unknownType;
    this.node_index_to_type_memoization = new HashMap<>();
    this.visited_node_indeces = new HashSet<>();
  }

  private DataType build_ctype(int node_index) {
    var target_node = this.mapping.getTypeIdToCtypeMap().get(node_index);
    Objects.requireNonNull(target_node);

    CTypeBuilder bldr = new CTypeBuilder(node_index, target_node, this);
    return bldr.buildTarget();
  }

  private DataType rec_build_node_type_without_root(int node_index, int prev_index) {
    this.visited_node_indeces.add(prev_index);
    return this.build_node_type(node_index);
  }

  private DataType build_node_type(int node_index) {
    if (this.node_index_to_type_memoization.containsKey(node_index)) {
      return this.node_index_to_type_memoization.get(node_index);
    }

    // Prevent visiting recursive type indefinitely
    if (this.visited_node_indeces.contains(node_index)) {
      return this.unknownType.getDefaultUnkownType();
    }

    var res = this.build_ctype(node_index);
    this.node_index_to_type_memoization.put(node_index, res);
    return res;
  }

  private Optional<Pair<Tid, DataType>> get_type_of_tid(TidToTypeId type_var) {
    if (this.mapping.containsTypeIdToCtype(type_var.getTypeId().getTypeId())) {
      return Optional.of(
          new Pair<Tid, DataType>(
              type_var.getTid(), this.build_node_type(type_var.getTypeId().getTypeId())));
    } else {
      return Optional.empty();
    }
  }

  private void initializeUnion(Ctypes.Union union, UnionDataType uniondt) {

    var unsorted_flds = union.getTargetTypeIdsList();

    for (var fld : unsorted_flds) {
      // safe because this type is already memoized
      var child_ty = this.build_node_type(fld.getTypeId());
      uniondt.add(child_ty);
    }
  }

  private static class InsertedField {
    public int bit_size;
    public int byte_offset;

    public InsertedField(int bit_size, int byte_offset) {
      this.bit_size = bit_size;
      this.byte_offset = byte_offset;
    }

    public int get_byte_past_end() {
      return this.byte_offset + (this.bit_size / 8);
    }
  }

  private DataType initializeStructure(Structure struct, StructureDataType st) {

    var new_fld_list = new ArrayList<Pair<InsertedField, DataType>>();

    var unsorted_flds = struct.getFieldsList();

    var flds =
        unsorted_flds.stream()
            .sorted((Field f1, Field f2) -> Integer.compare(f1.getByteOffset(), f2.getByteOffset()))
            .collect(Collectors.toList());

    for (var fld : flds) {
      var min_unoccupied = 0;
      if (!new_fld_list.isEmpty()) {
        var last_elem = new_fld_list.get(new_fld_list.size() - 1);
        min_unoccupied = last_elem.first.get_byte_past_end();
      }

      if (fld.getByteOffset() != min_unoccupied) {
        assert (fld.getByteOffset() > min_unoccupied);
        var diff = fld.getByteOffset() - min_unoccupied;
        var diff_in_bits = diff * 8;
        var ifld = new InsertedField(diff_in_bits, min_unoccupied);
        new_fld_list.add(new Pair<>(ifld, this.unknownType.getUnknownDataTypeWithSize(diff)));
      }

      // safe because this type is already memoized
      var fld_ty = this.build_ctype(fld.getTypeId().getTypeId());

      var refined_ty = this.unknownType.refineDataTypeWithSize(fld_ty, fld.getBitSize() / 8);

      new_fld_list.add(
          new Pair<>(new InsertedField(fld.getBitSize(), fld.getByteOffset()), refined_ty));
    }

    for (var to_add : new_fld_list) {
      st.add(
          to_add.second,
          to_add.first.bit_size / 8,
          "field_at_" + Integer.toString(to_add.first.byte_offset),
          "autogen");
    }

    return st;
  }

  private void initializeStructuresAndUnions() {
    List<Pair<Structure, StructureDataType>> structs_to_initialize = new ArrayList<>();
    List<Pair<ctypes.Ctypes.Union, UnionDataType>> unions_to_initialize = new ArrayList<>();

    for (var ent : this.mapping.getTypeIdToCtypeMap().entrySet()) {
      var ty_case = ent.getValue().getInnerTypeCase();
      // all structures and unions should have placeholders now
      if (ty_case == InnerTypeCase.STRUCTURE) {
        var st =
            new StructureDataType("structure_for_type_id_" + Integer.toString(ent.getKey()), 0);
        this.node_index_to_type_memoization.put(ent.getKey(), st);
        structs_to_initialize.add(
            new Pair<Ctypes.Structure, StructureDataType>(ent.getValue().getStructure(), st));
      } else if (ty_case == InnerTypeCase.UNION) {
        var st = new UnionDataType("union_for_typeid_" + ent.getKey());
        this.node_index_to_type_memoization.put(ent.getKey(), st);
        unions_to_initialize.add(
            new Pair<Ctypes.Union, UnionDataType>(ent.getValue().getUnion(), st));
      }
    }

    for (var struct : structs_to_initialize) {
      this.initializeStructure(struct.first, struct.second);
    }

    for (var union : unions_to_initialize) {
      this.initializeUnion(union.first, union.second);
    }
  }

  public Types buildMapping() {

    this.initializeStructuresAndUnions();
    // memoization map

    Map<Tid, DataType> tid_mapping_memo =
        this.mapping.getTypeVariableReprNodesList().stream()
            .map((TidToTypeId type_var) -> this.get_type_of_tid(type_var))
            .filter((Optional<Pair<Tid, DataType>> pr) -> pr.isPresent())
            .map(Optional::get)
            .collect(Collectors.toMap((var pr) -> pr.first, (var pr) -> pr.second));

    return new Types(tid_mapping_memo);
  }

  public static TypeLibrary parseFromInputStream(
      InputStream target,
      Map<String, DataType> type_constants,
      IUnknownTypeBuilder unknownType,
      DataTypeManager dtm)
      throws IOException {
    var mapping = CTypeMapping.parseFrom(target);
    return new TypeLibrary(mapping, type_constants, unknownType, dtm);
  }
}
